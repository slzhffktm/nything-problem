import random as rnd
import copy as cpy

"""
function that returns integer:  maximum fitness function
@board: Board
"""
def maxFitnessFunction(board):
    knightPossibleMoves = 8
    queenPossibleMoves = 8
    bishopPossibleMoves = 4
    rookPossibleMoves = 4
    return (board.whiteKnight + board.blackKnight) * knightPossibleMoves + (board.whiteQueen + board.blackQueen) * queenPossibleMoves + (board.whiteBishop + board.blackBishop) * bishopPossibleMoves + (board.whiteRook + board.blackRook) * rookPossibleMoves

"""
function that returns integer:  Fitness function for each population generated by genetic algorithms
@board: Board
@pieces: List of pieces
"""
def countFitnessFunction(board, pieces):
    sameColorConflicts, diffColorConflicts = board.countConflicts(pieces)
    return maxFitnessFunction(board) - sameColorConflicts + diffColorConflicts

"""
function that trim the list into either left or right side
@pieces: List of pieces
@side: left or right
@idxSelection: the index number in which the list will be trimmed
"""
def selection(pieces, side, idxSelection):
    selectionPieces = []
    if(side == 'left'):
        for i in range(idxSelection):
            selectionPieces.append(pieces[i])
    elif(side == 'right'):
        for i in range(idxSelection, len(pieces)):
            selectionPieces.append(pieces[i])
    return selectionPieces
            
"""
function that return a list
@pieces: List of pieces
@side: left or right
@idxSelection: the index number in which the list will be trimmed
"""
def crossOver(pieces1,pieces2):
    idxSelection = rnd.randint(1, len(pieces1) - 1)
    part1 = selection(pieces1, 'left', idxSelection)
    part2 = selection(pieces2, 'right', idxSelection)
    result = []
    for leftSide in part1:
        result.append(leftSide)
    for rightSide in part2:
        result.append(rightSide)
    for leftSide in part1:
        for rightSide in part2:
            if (leftSide.x == rightSide.x and leftSide.y == rightSide.y):
                return []
    return result

"""
function that return a new list of pieces with mutation
@pieces: List of pieces
@maps: chess maps
"""
def mutation(pieces, maps):
    idxSelection = rnd.randint(0, len(pieces)-1)
    mutationPieces = cpy.deepcopy(pieces)
    newX = rnd.randint(0,7)
    newY = rnd.randint(0,7)
    while(maps[7 - newY][newX] != '.'):
        newX = rnd.randint(0,7)
        newY = rnd.randint(0,7)
    newY = 7 - newY
    mutationPieces[idxSelection].x = newX
    mutationPieces[idxSelection].y = newY
    return mutationPieces

"""
function that return list with random piece's position
@pieces: List of pieces
@maps: chess maps
"""
def randAllPiece(pieces, maps):
    tempMaps = cpy.deepcopy(maps)
    for piece in pieces:
        newX = rnd.randint(0,7)
        newY = rnd.randint(0,7)
        while(tempMaps[7 - newY][newX] != '.'):
            newX = rnd.randint(0,7)
            newY = rnd.randint(0,7)
        newY = 7 - newY
        piece.x = newX
        piece.y = newY
        tempMaps[piece.y][piece.x] = piece.getChar()
    return pieces

"""
function to solve nything-problem using simulated annealing
@board: Board
"""
def genetic(board):
    nPopulation = 100
    population = []
    for i in range (nPopulation):
        temp = cpy.deepcopy(randAllPiece(board.pieces, board.maps))
        population.append([temp, countFitnessFunction(board, temp)])
    cleanPopulation = []
    population.sort(key=lambda x:x[1])
    for individual in population:
        if (individual[1] > maxFitnessFunction(board)/2):
            cleanPopulation.append(individual)
    cleanPopulation.sort(key=lambda x:x[1], reverse=True)
    nCleanPopulation = len(cleanPopulation)
    for j in range(1000):
        if(cleanPopulation[0][1] != maxFitnessFunction(board)):
            for i in range(len(cleanPopulation)-1):
                if (i+1 < len(cleanPopulation)):
                    child = crossOver(cleanPopulation[i][0],cleanPopulation[i+1][0])
                if (child != []):
                    board.update(child)
                    cleanPopulation.append([child, countFitnessFunction(board, child)])
            mutationIndex = rnd.randint(0,len(cleanPopulation)-1)
            tempBoard = cpy.deepcopy(board)
            tempBoard.update(cleanPopulation[mutationIndex][0])
            cleanPopulation[mutationIndex][0] = mutation(cleanPopulation[mutationIndex][0], tempBoard.maps)
            cleanPopulation[mutationIndex][1] = countFitnessFunction(board,cleanPopulation[mutationIndex][0])
            cleanPopulation.sort(key=lambda x:x[1], reverse=True)
            cleanPopulation = cleanPopulation[:nCleanPopulation]
        else:
            break
    print("Genetic Algorithm")
    board.update(cleanPopulation[0][0])
    print("Solution")
    board.show()    
